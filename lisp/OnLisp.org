#+TITLE:     OnLisp
#+AUTHOR:    
#+EMAIL:     
#+DATE:      
#+LATEX_CLASS: ctexart
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:

* 可扩展语言
Lisp本身就是一个Lisp程序，Lisp程序可以表达成列表，那也是Lisp的数据结构。总之，这两个原则意味着任何用户都可以为Lisp增加新的操作符，而这些新成员和那些内置的操作符是没有区别的。
** 渐进式设计
由于Lisp赋予了你自己定义操作符的自由，因而你得以随心所欲地将它塑造成你所需要的语言。
** 自底向上程序设计
即通过改变语言来适应程序。在Lisp中，你不仅是根据语言向下编写程序，也可以根据程序向上构造语言。
- 通过让语言担当更多的工作，自底向上设计产生的程序会更加短小轻快。一个更短小的程序就不必划分成那么多的组件了，并且更少的组件意味着程序会更易于阅读和修改。更少的组件也使得着组件之间的连接会更少，因而错误发生的机会也会相应减少。一个机械设计师往往努力去减少机器上运动部件和数量，同样有经验和lisp程序员使用自底向上的设计方法来减小他们程序的规模和复杂度。
- 自底向上的设计促进了代码重用。当你写两个或更多程序时，许多你为第一个程序写的工具也会对之后的程序开发有帮助。一旦积累下了雄厚的工具基础，写一个新程序所耗费的精力和从原始(raw）Lisp环境白手起家相比，前者可能只是后者的几分之一。
- 自底向上的设计提高了程序的可读性。一个这种类型的抽象要求读者理解一个通用操作符，而一个具体的函数抽象要求读者去理解的则是一个专用的子例程。
- 由于自底向上的设计驱使你总是去关注代码中的模式，这种工作方式有助于理清设计程序时的思路。如果一个程序中两个关系很远的组件在形式上很相似，你就会因此注意到这种相似性，然后也许会以更简单的方式重新设计程序。
** 可扩展软件
自底向上的设计很自然地产生了可扩展的程序。最简单的自底向上程序包括两层：语言和程序。复杂和程序可以被写成多个层次，每一层作为其上层的编程语言。如果一个可扩展性体现在每一层次的程序，与那些先按照传统黑盒方法写成，事后才加上可扩展性的那些系统相比，更有可能成为一门好得多的编程语言。
** 扩展Lisp
有两种方式可以为Lisp增加新的操作符：函数和宏。在lisp里，你定义和函数和那些内置函数具有相同的地位。
定义函数相对而言比较直截了当。而用宏来定义新操作符，虽然更通用，但不太容易理解。宏是用来写程序的程序。这句话意味深长，深入地探究这个问题正是本书的主要目的之一。
在Lisp里，程序就是数据。
如果需要，你可以在Lisp之上构造一个完整的语言，然后用它来编写程序。
嵌入式语言是自底向上程序设计和自然产物。CommonLisp里已经有了好几种这样的语言。
** 为什么（或说何时）用Lisp
* 函数
函数不仅是Lisp程序的根基，它同时也是Lisp语言的基石。
** 作为数据的函数
有两点让Lisp函数与众不同。一是前面提到的，Lisp本身就是函数的集合。这意味着我们可以自己给Lisp增加新的操作符。另一个关于函数的重要问题，是要了解：函数也是Lisp的对象。
但对于Lisp来说，在运行期创建新函数的技术简直就是家常便饭。
** 定义函数
> (defun double (x) (* x 2))
DOUBLE
CommonLisp的函数是第一类(first-class)对象，它和整数和字符串这些更熟悉的对象享有完全相同的权利。所以，我们既可以把这个函数作为参数传递，也可以把它作为返回值返回，还能把它存在数据结构里。
> (eq #'double (car (list #'double)))
T
甚至可以不用defun来定义函数。和大多数Lisp对象一样，我们也可以通过其文字表达的形式来引用它。
(lambda (x) (* x 2))
它描述了一个函数，函数的参数是x,并且返回2x。
defun和其它语言的过程定义的效果相同---把一个名字和一段代码关联起来。
** 函数参数
函数同为数据对象，就意味着我们可以像对待其他对象那样把它传递给其他函数。这种性质对于Lisp这种自底向上设计至关重要。
如果一门语言把函数作为数据对象，那么它必然也会提供某种方式让我们调用它们。在Lisp里，这个函数就是apply。一般而言，我们用两个参数来调用apply:函数和它的参数列表。下面四个表达式的效果是一样的：
(+ 1 2)
(apply #'+ '(1 2))
(apply (symbol-function '+) '(1 2))
(apply #'(lambda (x y) (+ x y)) '(1 2))
还有
(apply #'+ 1 '(2))
如果 *不方便* 以列表的形式提供参数，可以使用funcall，它和apply唯一的区别也在于此。
(funcall #'+ 1 2)
CommonLisp和它以前方言之间一个最大的区别就是它拥有大量使用函数型参数的内置函数。
** 作为属性的函数
** 作用域
CommonLisp是一种词法作用域(lexically scope)的Lisp。Scheme是最早的有词法作用域的方言；在它之前，动态作用域(dynamic scope)被视为Lisp的本质属性之一。
词法作用域和动态作用域的区别在于语言处理自由变量的方式不同。当一个符号用来表达变量时，我们称这个符号在表达式中是被绑定的(bound)，这里的变量可以是参数，也可以是来自像let和do这样的变量绑定操作符。如果符号不受到约束，就认为它是自由的。
(let ((y 7))
  (defun scope-test (x)
    (list x y)))
** 闭包
由于CommonLisp是词法作用域的，所以如果定义含有自由变量的函数，系统就必须在函数定义时保存那些变量的绑定。这种函数和一级变量绑定的组合称为闭包。
我们发现，闭包在各种场合都能大显身手。闭包在CommonLisp程序中如此无所不在，以致于你可能已经用了它却浑然不知。每当你传给mapcar一个包含自由变量的前缀#'的lambda-表达式时，你就在使用闭包。例如：
(defun list+ (lst n)
  (mapcar #'(lambda (x) (+ x n))
    lst))

> (list+ '(1 2 3) 10)
(11 12 13)

** 局部函数
** 尾函数
** 编译
** 来自列表的函数
* 函数式编程
** 函数式设计
函数式编程意味着利用返回值而不是副作用来写程序。
** 内外颠倒的命令式
对于其他语言的同行来说，刚开始使用Lisp可能像初次踏入溜冰场那样。事实上在冰上比在干地面上更容易行走---如果使用溜冰鞋的话。然后你对这项运动的看法就会彻底改观。
溜冰鞋对冰的意义，和函数式编程对Lisp的意义是一样的。
** 函数式接口
** 交互式编程
事实上有经验的Lisp程序员会尽量让他们的程序易于测试：
- 他们试图把副作用分离到个别函数里，以便程序中更多的部分可以写成纯函数式风格。
- 如果一个函数必须产生副作用，他们至少会想办法给它设计一个函数式的接口。
- 他们给每个函数赋予一个单一的，定义良好的功能。
* 实用函数
Common Lisp操作符分为三类：可自定义的函数和宏，以及不能自定义的特殊形式(special form)。
编写Lisp扩展的难点并不在于代码怎么写，而在于决定写什么。
** 实用工具的诞生
学习编写实用工具与其说是学习编写的技术，不如说是养成编写实用工具的习惯。自底向上程序设计意味着在编写程序的同时，也在设计一门编程语言。为了做好这一点，你必须培养出一种能看出程序中缺少何种操作符的洞察力。你必须能够在看到一个程序时说，“啊，其实你真正的意思是这个。”
Lisp编程的要求之一，就是一旦有需要，就应该构思出新的实用工具。本章的目的就是提示这些工具是如何人无到有的。

** 投资抽象
** 列表上的操作
** 搜索
before
> (before 'b 'd '(a b c d))
(B C D)
** 映射
** I/O
** 符号和字符串
** 紧凑性
* 函数作为返回值
** Common Lisp的演化
** 正交性
** 记住过去
** 复合函数
** 在cdr上递归
** 在子树上递归
** 何时构造函数
* 函数作为表达式
** 网络
** 编译后的网络
** 展望
* 宏
** 宏是如何工作的
** 反引用(backquote)
** 定义简单的宏
** 测试宏展开
** 参数列表的解构
** 宏的工作模式
** 作为程序的宏
** 宏风格
** 宏的依赖关系
** 来自函数的宏
** 符号宏(symbol-macro)
* 何时使用宏
** 当别无他法时
** 宏还是函数?
** 宏的应用场合
* 变量捕捉
** 宏参数捕捉
** 自由符号捕捉
** 捕捉发生的时机
** 取更好的名字避免捕捉
** 通过预先求值避免捕捉
** 通过gensym避免捕捉
** 通过包避免捕捉
** 其他名字空间里的捕捉
** 为何要庸人自扰？
* 其他的宏陷阱
** 求值的次数
** 求值的顺序
** 非函数式的展开器
** 递归
* 经典宏
** 创建上下文
** with-宏
** 条件求值
** 迭代
** 多值迭代
** 需要宏的原因
* 广义变量
** 概念
** 多重求值问题
** 新的实用工具
** 更复杂的实用工具
** 定义逆
* 编译期计算
** 新的实用工具
** 举例：贝塞尔曲线
** 应用
* 指代宏
** 指代的种种变形
** 失败
** 引用透明(Referential Transparency)
* 返回函数的宏
** 函数的构造
** 在cdr上做递归 
** 在子树上递归
** 惰性求值
* 定义宏的宏
** 缩略语
** 属性
** 指代宏
* 读取宏
** 宏字符
** dispatching宏字符
** 定界符
** 这些发生于何时
* 解构
** 列表上的解构
** 其他结构
** 引用
** 匹配
* 一个查询编译器
** 数据库
** 模式匹配查询
** 一个查询解释器
** 绑定上的限制
** 一个查询编译器
* 续延
** Scheme续延
** 续延传递宏
** Code-Walker和CPS Conversion
* 多进程
** 进程抽象
** 实现
** 不那么快速的原型
* 非确定性
** 概念
** 搜索
** Scheme实现
** Common Lisp实现
** 减枝
** 真正的非确定性
* 使用ATN分析句子
** 背景知识
** 形式化
** 非确定性
** 一个ATN编译器
** 一个ATN的例子
* Prolog
** 概念
** 解释器
** 规则
** 对于非确定性的需要
** 新的实现
** 增添Prolog特性
** 例子
** 编译的含义
* 面向对象的Lisp
** 万变不离其宗
** 阳春版Lisp中的对象
** 类和实例
** 方法
** 辅助方法和组合
** CLOS与Lisp
** 何时用对象
